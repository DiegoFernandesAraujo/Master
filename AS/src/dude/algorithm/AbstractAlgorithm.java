/*
 * DuDe - The Duplicate Detection Toolkit
 * 
 * Copyright (C) 2010  Hasso-Plattner-Institut f√ºr Softwaresystemtechnik GmbH,
 *                     Potsdam, Germany 
 *
 * This file is part of DuDe.
 * 
 * DuDe is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * DuDe is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DuDe.  If not, see <http://www.gnu.org/licenses/>.
 * 
 */

package dude.algorithm;

import java.io.IOException;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Vector;

import dude.datasource.DataSource;
import dude.preprocessor.Preprocessor;
import dude.util.AbstractCleanable;
import dude.util.data.DuDeObject;
import dude.util.data.DuDeObjectPair;
import dude.util.data.DuDeObjectPair.GeneratedBy;
import dude.util.data.storage.DuDeStorage;
import dude.util.data.storage.FileBasedStorage;
import dude.util.data.storage.InMemoryStorage;

/**
 * <code>AbstractAlgorithm</code> implements the functionality that is needed by each algorithm type.
 * 
 * @author Matthias Pohl
 */
public abstract class AbstractAlgorithm extends AbstractCleanable implements Algorithm {

	/**
	 * <code>AlgorithmIteratorWrapper</code> is used for setting some common properties of the generated {@link DuDeObjectPair}s.
	 * 
	 * @author Matthias Pohl
	 */
	protected static class AlgorithmIteratorWrapper implements Iterator<DuDeObjectPair> {

		private final Iterator<DuDeObjectPair> iterator;

		/**
		 * Initializes a <code>AbstractAlgorithm.AlgorithmIteratorWrapper</code> with the passed {@link Iterator}.
		 * 
		 * @param it
		 *            The iterator of which the data shall be changed.
		 */
		protected AlgorithmIteratorWrapper(Iterator<DuDeObjectPair> it) {
			this.iterator = it;
		}

		@Override
		public boolean hasNext() {
			return this.iterator.hasNext();
		}

		@Override
		public DuDeObjectPair next() {
			final DuDeObjectPair nextPair = this.iterator.next();

			// sets the lineage property for each pair generated by an Algorithm instance
			nextPair.setLineage(GeneratedBy.Algorithm);
			return nextPair;
		}

		@Override
		public void remove() {
			this.iterator.remove();
		}
	}

	private Vector<DuDeObject> objects = new Vector<DuDeObject>();
	// the Preprocessors that are used within every DataSource
	private final Collection<Preprocessor> defaultPreprocessors = new ArrayList<Preprocessor>();

	// the DataSource-related Preprocessors
	private final Map<DataSource, Collection<Preprocessor>> preprocessors = new HashMap<DataSource, Collection<Preprocessor>>();

	// the flag that indicates whether in-memory processing is enabled
	// in-memory processing is disabled by default
	private boolean inMemoryProcessingEnabled = false;

	// the flag that indicates whether the data was already extracted
	private transient boolean dataExtracted = false;

	@Override
	public void addPreprocessor(Preprocessor preprocessor) {
		if (preprocessor != null) {
			this.defaultPreprocessors.add(preprocessor);
		}
	}

	@Override
	public void addPreprocessor(DataSource source, Preprocessor preprocessor) {
		if (source == null) {
			this.addPreprocessor(preprocessor);
			return;
		}

		if (this.preprocessors.containsKey(source)) {
			this.preprocessors.get(source).add(preprocessor);
		} else {
			Collection<Preprocessor> newCollection = new ArrayList<Preprocessor>();
			newCollection.add(preprocessor);
			this.preprocessors.put(source, newCollection);
		}
	}

	@Override
	public Vector<DuDeObject> getExtractedData(){
		return this.objects;
	}
	/**
	 * Initiates the preprocessing for the passed {@link DuDeObject}.
	 * 
	 * @param object
	 *            The <code>DuDeObject</code> that shall be preprocessed.
	 */
	protected void analyzeDuDeObject(DuDeObject object) {
		// default preprocessors
		for (Preprocessor preprocessor : this.defaultPreprocessors) {
			preprocessor.analyzeDuDeObject(object);
		}
		this.objects.add(object);
		// DataSource-related preprocessors
		for (Map.Entry<DataSource, Collection<Preprocessor>> entry : this.preprocessors.entrySet()) {
			if (entry.getKey().getIdentifier().equals(object.getSourceId())) {
				for (Preprocessor preprocessor : entry.getValue()) {
					preprocessor.analyzeDuDeObject(object);
				}
			}
		}
	}

	/**
	 * Executes {@link Preprocessor#finish()} method of each added {@link Preprocessor}.
	 */
	protected void finishPreprocessing() {
		for (final Collection<Preprocessor> preprocessorColl : this.preprocessors.values()) {
			for (final Preprocessor preprocessor : preprocessorColl) {
				preprocessor.finish();
			}
		}
	}

	@Override
	public void enableInMemoryProcessing() {
		this.inMemoryProcessingEnabled = true;
	}

	@Override
	public void disableInMemoryProcessing() {
		this.inMemoryProcessingEnabled = false;
	}

	@Override
	public boolean inMemoryProcessingEnabled() {
		return this.inMemoryProcessingEnabled;
	}

	/**
	 * Creates the {@link DuDeStorage} instance based on the in-memory-processing flag.
	 * 
	 * @param name
	 *            The name of the storage, if a {@link FileBasedStorage} is instantiated.
	 * @return The <code>DuDeStorage</code> instance.
	 * @throws IOException
	 *             If an IO error occurred while instantiating the storage.
	 */
	protected DuDeStorage<DuDeObject> createStorage(String name) throws IOException {
		if (name == null) {
			throw new NullPointerException();
		}

		if (this.inMemoryProcessingEnabled()) {
			return new InMemoryStorage<DuDeObject>();
		}

		return new FileBasedStorage<DuDeObject>(DuDeObject.class, name);
	}

	/**
	 * Sets a flag which indicates that the extraction process is finished.
	 */
	protected void finishExtraction() {
		this.dataExtracted = true;
	}

	/**
	 * Forces a new initialization phase before returning the next {@link Iterator}. This initialization includes extraction and preprocessing.
	 */
	public void forceExtraction() {
		this.dataExtracted = false;
	}

	/**
	 * Checks whether the data extraction was already done.
	 * 
	 * @return <code>true</code>, if the data was already extracted; otherwise <code>false</code>.
	 */
	protected boolean dataExtracted() {
		return this.dataExtracted;
	}

	@Override
	public int getDataSize(DataSource source) {
		if (source == null) {
			throw new NullPointerException();
		} else if (!this.dataSourceAttached(source)) {
			throw new IllegalArgumentException("The passed source is not attached to this algorithm.");
		}

		return source.getExtractedRecordCount();
	}

	@Override
	public abstract int getDataSize();

	@Override
	public void addDataSource(DataSource source) {
		if (source == null) {
			throw new NullPointerException();
		}

		this.registerCleanable(source);
		this.addSource(source);

		// if a new DataSource is added, the extraction process has to be redone
		this.forceExtraction();
	}

	/**
	 * Checks whether the passed {@link DataSource} is attached to this <code>AbstractAlgorithm</code> instance.
	 * 
	 * @param source
	 *            The <code>DataSource</code> that shall be checked.
	 * @return <code>true</code>, if the passed <code>DataSource</code> was added to this instance; <code>false</code> otherwise or <code>null</code>
	 *         was passed.
	 */
	protected abstract boolean dataSourceAttached(DataSource source);

	/**
	 * Adds the {@link DataSource} to this instance.
	 * 
	 * @param source
	 *            The <code>DataSource</code> that shall be added.
	 */
	protected abstract void addSource(DataSource source);

	/**
	 * Starts the extraction and preprocessing phase if necessary and returns an {@link Iterator} instance for iterating over the algorithm's result.
	 */
	@Override
	public abstract Iterator<DuDeObjectPair> iterator();

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + (this.dataExtracted ? 1231 : 1237);
		result = prime * result + ((this.defaultPreprocessors == null) ? 0 : this.defaultPreprocessors.hashCode());
		result = prime * result + (this.inMemoryProcessingEnabled ? 1231 : 1237);
		result = prime * result + ((this.preprocessors == null) ? 0 : this.preprocessors.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}

		if (obj == null) {
			return false;
		}

		if (this.getClass() != obj.getClass()) {
			return false;
		}

		AbstractAlgorithm other = (AbstractAlgorithm) obj;
		if (this.dataExtracted != other.dataExtracted) {
			return false;
		}

		if (this.defaultPreprocessors == null) {
			if (other.defaultPreprocessors != null) {
				return false;
			}
		} else if (!this.defaultPreprocessors.equals(other.defaultPreprocessors)) {
			return false;
		}

		if (this.inMemoryProcessingEnabled != other.inMemoryProcessingEnabled) {
			return false;
		}

		if (this.preprocessors == null) {
			if (other.preprocessors != null) {
				return false;
			}
		} else if (!this.preprocessors.equals(other.preprocessors)) {
			return false;
		}

		return true;
	}

}
