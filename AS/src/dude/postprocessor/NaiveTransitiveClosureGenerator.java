/*
 * DuDe - The Duplicate Detection Toolkit
 * 
 * Copyright (C) 2010  Hasso-Plattner-Institut f√ºr Softwaresystemtechnik GmbH,
 *                     Potsdam, Germany 
 *
 * This file is part of DuDe.
 * 
 * DuDe is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * DuDe is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DuDe.  If not, see <http://www.gnu.org/licenses/>.
 * 
 */

package dude.postprocessor;

import java.util.AbstractSet;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import dude.util.AbstractIterator;
import dude.util.data.DuDeObject;
import dude.util.data.DuDeObjectPair;
import dude.util.data.DuDeObjectPair.GeneratedBy;

/**
 * <code>NaiveTransitiveClosureGenerator</code> implements the naive way of generating transitive closures. It is memory-based and not optimized in
 * any sense (simple nested-for-loop approach). The transitive closures can be returned in two ways:
 * <ol>
 * <li/>Using {@link #getTransitiveClosures()} - this will return a 2-dimensional collection with each {@link DuDeObject} listed in its transitive
 * closure.
 * <li/>Using the {@link Iterator} interface - this will return all {@link DuDeObjectPair}s.
 * </ol>
 * 
 * @author Matthias Pohl
 * @author David Sonnabend
 */
public class NaiveTransitiveClosureGenerator implements Iterable<DuDeObjectPair> {

	/**
	 * <code>TransitiveClosure</code> represents one transitive closure.
	 * 
	 * @author Matthias Pohl
	 */
	protected class TransitiveClosure extends AbstractSet<DuDeObject> {

		private Collection<DuDeObject> transitiveClosure = new HashSet<DuDeObject>();

		/**
		 * Initializes a {@link TransitiveClosure}.
		 * 
		 * @param firstPair
		 *            The first pair that will be added.
		 */
		public TransitiveClosure(DuDeObjectPair firstPair) {
			this.transitiveClosure.add(firstPair.getFirstElement());
			this.transitiveClosure.add(firstPair.getSecondElement());
		}

		/**
		 * Checks whether at least one element of the pair is already within this transitive closure.
		 * 
		 * @param pair
		 *            The pair whose elements shall be checked.
		 * @return <code>true</code>, if one of the elements is already member of the transitive closure; otherwise <code>false</code>.
		 */
		public boolean contains(DuDeObjectPair pair) {
			return this.transitiveClosure.contains(pair.getFirstElement()) || this.transitiveClosure.contains(pair.getSecondElement());
		}

		/**
		 * Checks whether the passed {@link DuDeObject} is already member of the transitive closure.
		 * 
		 * @param object
		 *            The <code>DuDeObject</code> that shall be checked.
		 * @return <code>true</code>, if this object is already member of the transitive closure; otherwise <code>false</code>.
		 */
		public boolean contains(DuDeObject object) {
			return this.transitiveClosure.contains(object);
		}

		/**
		 * Adds the elements of the passed pair to the transitive closure. If one of the elements is already member of the transitive closure it won't
		 * be added a second time.
		 * 
		 * @param pair
		 *            The pair whose elements shall be added.
		 */
		public void add(DuDeObjectPair pair) {
			this.transitiveClosure.add(pair.getFirstElement());
			this.transitiveClosure.add(pair.getSecondElement());
		}

		/**
		 * Merges the passed <code>TransitiveClosure</code> with the current one.
		 * 
		 * @param closure
		 *            The <code>TransitiveClosure</code> that shall be merged with the current one.
		 */
		public void merge(TransitiveClosure closure) {
			this.transitiveClosure.addAll(closure);
		}

		@Override
		public Iterator<DuDeObject> iterator() {
			return this.transitiveClosure.iterator();
		}

		@Override
		public int size() {
			return this.transitiveClosure.size();
		}
	}

	/**
	 * <code>NaiveTransitiveClosureGenerator.TransitiveClosureIterator</code> is used to iterate over all pairs collected or generated by the
	 * <code>NaiveTransitiveClosureGenerator</code>.
	 * 
	 * @author Matthias Pohl
	 */
	protected class TransitiveClosureIterator extends AbstractIterator<DuDeObjectPair> {

		private Iterator<NaiveTransitiveClosureGenerator.TransitiveClosure> overAllClosureIterator;

		private NaiveTransitiveClosureGenerator.TransitiveClosure currentTransitiveClosure;

		private Iterator<DuDeObject> outerIterator;
		private Iterator<DuDeObject> innerIterator;

		private DuDeObject outerElement;
		private int outerElementIndex;
		
		private final Collection<DuDeObjectPair> algorithmGeneratedData = NaiveTransitiveClosureGenerator.this.data;

		private TransitiveClosureIterator() {
			this.overAllClosureIterator = NaiveTransitiveClosureGenerator.this.transitiveClosures.iterator();
			this.loadNextCurrentClosureIterator();
		}

		@Override
		protected DuDeObjectPair loadNextElement() {
			if (this.innerIterator == null) {
				return null;
			}

			if (!this.innerIterator.hasNext()) {
				this.loadNextOuterElement();
			}

			if (this.endOfContentReached()) {
				return null;
			}

			final DuDeObjectPair generatedPair = new DuDeObjectPair(this.outerElement, this.innerIterator.next());
			
			if (this.algorithmGeneratedData.contains(generatedPair)) {
				final DuDeObjectPair actualPair = this.getActualPair(generatedPair);
				
				if (actualPair == null) {
					throw new IllegalStateException("The generated pair could not be found in the algorithm's pair set.");
				}
				
				return actualPair;
			}
			
			generatedPair.setLineage(GeneratedBy.TransitiveClosure);
			return generatedPair;
		}
		
		private DuDeObjectPair getActualPair(DuDeObjectPair pairCopy) {
			for (DuDeObjectPair pair : this.algorithmGeneratedData) {
				if (pair.equals(pairCopy)) {
					return pair;
				}
			}
			
			return null;
		}

		private boolean endOfContentReached() {
			return this.outerElement == null;
		}

		private void loadNextCurrentClosureIterator() {
			if (this.overAllClosureIterator == null || !this.overAllClosureIterator.hasNext()) {
				this.outerElement = null;
				return;
			}

			this.currentTransitiveClosure = this.overAllClosureIterator.next();
			this.outerIterator = this.currentTransitiveClosure.iterator();
			this.innerIterator = this.currentTransitiveClosure.iterator();

			this.outerElement = this.outerIterator.next();
			this.outerElementIndex = 0;

			// jump over first element in order to prevent reflexive pairs
			this.innerIterator.next();
		}

		private void loadNextOuterElement() {
			if (this.outerIterator == null) {
				return;
			}

			if (!this.outerIterator.hasNext()) {
				this.loadNextCurrentClosureIterator();
				return;
			}

			this.outerElement = this.outerIterator.next();
			++this.outerElementIndex;

			this.innerIterator = this.currentTransitiveClosure.iterator();

			// jump to the position right after the one the outer iterator is pointing to (to avoid symmetric and
			// reflexive pairs)
			for (int i = 0; i <= this.outerElementIndex; i++) {
				this.innerIterator.next();
			}

			if (!this.innerIterator.hasNext()) {
				this.loadNextCurrentClosureIterator();
			}
		}

	}

	private Collection<DuDeObjectPair> data = new HashSet<DuDeObjectPair>();

	private List<NaiveTransitiveClosureGenerator.TransitiveClosure> transitiveClosures = new ArrayList<NaiveTransitiveClosureGenerator.TransitiveClosure>();

	/**
	 * Generates a new transitive closure that contains the passed pair initially and adds it to the transitive closures collection.
	 * 
	 * @param pair
	 *            The two elements that will be added to the new transitive closure.
	 */
	private void addNewTransitiveClosure(DuDeObjectPair pair) {
		this.transitiveClosures.add(new TransitiveClosure(pair));
	}

	/**
	 * Generates the transitive closures out of the collected data.
	 */
	private void generateTransitiveClosures() {

		for (DuDeObjectPair pair : this.data) {
			// checks if the current pair is part of a new transitive closure or can be added to an existing one
			boolean newTransitiveClosure = true;
			for (TransitiveClosure transitiveClosure : this.transitiveClosures) {
				if (transitiveClosure.contains(pair)) {
					transitiveClosure.add(pair);
					newTransitiveClosure = false;
					break;
				}
			}
			if (newTransitiveClosure) {
				this.addNewTransitiveClosure(pair);
			}
		}

		// checks if any transitive closures were merged (the loop will continue until this value is false -> no
		// transitive closures could be merged)
		boolean changed = true;
		int cnt = 0;
		while (changed) {
			++cnt;

			// stores the information which transitive closures can be merged
			Map<Integer, Collection<Integer>> toMerge = new HashMap<Integer, Collection<Integer>>();
			// stores all transitive closures which are already flagged and will be merged with another transitive
			// closure
			Collection<Integer> ignoreMerging = new HashSet<Integer>();
			changed = false;

			for (int i = 0; i < this.transitiveClosures.size(); ++i) {
				TransitiveClosure outerClosure = this.transitiveClosures.get(i);
				toMerge.put(i, new HashSet<Integer>());
				for (int j = i + 1; j < this.transitiveClosures.size(); ++j) {
					TransitiveClosure innerClosure = this.transitiveClosures.get(j);
					for (DuDeObject obj : innerClosure) {
						if (outerClosure.contains(obj)) {
							// inner and outer closure must be merged
							toMerge.get(i).add(j);
							ignoreMerging.add(j);
							changed = true;
							break;
						}
					}
				}
			}

			// merge transitive closures
			List<TransitiveClosure> mergedTransitiveClosures = new ArrayList<TransitiveClosure>();

			for (Entry<Integer, Collection<Integer>> mergeInfo : toMerge.entrySet()) {
				if (ignoreMerging.contains(mergeInfo.getKey())) {
					continue;
				}

				TransitiveClosure closure = this.transitiveClosures.get(mergeInfo.getKey());
				for (int closureID : mergeInfo.getValue()) {
					closure.merge(this.transitiveClosures.get(closureID));
				}

				mergedTransitiveClosures.add(closure);
			}

			this.transitiveClosures = mergedTransitiveClosures;
		}
	}

	/**
	 * Adds a pair to the <code>NaiveTransitiveClosureGenerator</code>.
	 * 
	 * @param pair
	 *            The pair that shall be added.
	 */
	public void add(DuDeObjectPair pair) {
		this.data.add(pair);
	}

	/**
	 * Adds a <code>Collection</code> of pairs to the <code>NaiveTransitiveClosureGenerator</code>.
	 * 
	 * @param pairs
	 *            The pairs that shall be added.
	 */
	public void add(Collection<DuDeObjectPair> pairs) {
		this.data.addAll(pairs);
	}

	/**
	 * Returns the transitive closures as a 2-dimensional collection.
	 * 
	 * @return The transitive closures.
	 */
	public Collection<? extends Collection<DuDeObject>> getTransitiveClosures() {
		this.generateTransitiveClosures();

		return this.transitiveClosures;
	}

	@Override
	public Iterator<DuDeObjectPair> iterator() {
		this.generateTransitiveClosures();

		return new TransitiveClosureIterator();
	}
}
