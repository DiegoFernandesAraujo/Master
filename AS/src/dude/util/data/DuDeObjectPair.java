/*
 * DuDe - The Duplicate Detection Toolkit
 * 
 * Copyright (C) 2010  Hasso-Plattner-Institut f√ºr Softwaresystemtechnik GmbH,
 *                     Potsdam, Germany 
 *
 * This file is part of DuDe.
 * 
 * DuDe is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * DuDe is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DuDe.  If not, see <http://www.gnu.org/licenses/>.
 * 
 */

package dude.util.data;

import java.io.IOException;

import org.codehaus.jackson.JsonGenerationException;
import org.codehaus.jackson.JsonParseException;

import dude.util.OrderedPair;
import dude.util.data.json.DuDeJsonGenerator;
import dude.util.data.json.DuDeJsonParser;
import dude.util.data.json.JsonArray;
import dude.util.data.json.JsonNumber;
import dude.util.data.json.JsonRecord;
import dude.util.data.json.JsonString;

/**
 * <code>DuDeObjectPair</code> is an extension of the {@link OrderedPair} class,
 * that encapsulates pairs of {@link DuDeObject}s.
 * 
 * @author Matthias Pohl
 * 
 * @see DuDeObject
 */
public class DuDeObjectPair extends OrderedPair<DuDeObject> implements Jsonable {

	/**
	 * This value will be returned, if no similarity was set.
	 */
	public static final double NO_SIMILARITY_SET_VALUE = -1.0;

	/**
	 * The first element's Json attribute name.
	 */
	public static final String FIRST_ELEMENT_ATTRIBUTE_NAME = "first-element";

	/**
	 * The second element's Json attribute name.
	 */
	public static final String SECOND_ELEMENT_ATTRIBUTE_NAME = "second-element";

	/**
	 * The name of the similarity property.
	 */
	protected static final String SIMILARITY_PROPERTY = "similarity";

	/**
	 * The name of the lineage property.
	 */
	protected static final String LINEAGE_PROPERTY = "lineage";

	/**
	 * <code>DuDeObjectPair.GeneratedBy</code> declares the possible values for
	 * the <code>lineage</code> property.
	 * 
	 * @author Matthias Pohl
	 */
	public enum GeneratedBy {
		/**
		 * This type shall be used, if the <code>DuDeObjectPair</code> was
		 * generated by the algorithm.
		 */
		Algorithm,
		/**
		 * This type shall be used, if the <code>DuDeObjectPair</code> was
		 * generated by a transitive closure.
		 */
		TransitiveClosure,
		/**
		 * This type shall be used, if the lineage cannot be determined.
		 */
		NotDefined
	}

	/**
	 * The name of the property that indicates, if the current pair is a
	 * duplicate.
	 */
	protected static final String DUPLICATE_PROPERTY = "is-duplicate";

	/**
	 * <code>DuDeObjectPair.DuplicateType</code> declares all possible values
	 * for the <code>is-duplicate</code> property.
	 * 
	 * @author Matthias Pohl
	 */
	public enum DuplicateType {
		/**
		 * This type is used for indicating duplicates.
		 */
		Duplicate,
		/**
		 * This type is used if the algorithm could not determine whether it is
		 * a duplicate or a non-duplicate.
		 */
		Fuzzy,
		/**
		 * This type is used if the pair represents no duplicate.
		 */
		NonDuplicate,
		/**
		 * This type indicates that the property was not set, yet.
		 */
		NotDefined
	}

	@SuppressWarnings("unused")
	private DuDeObjectPair() {
		this(new DuDeObject("", ""), new DuDeObject("", ""));
	}

	/**
	 * Initializes a pair of {@link DuDeObject}s.
	 * 
	 * @param first
	 *            The first <code>DuDeObject</code>.
	 * @param second
	 *            The second <code>DuDeObject</code>.
	 */
	public DuDeObjectPair(DuDeObject first, DuDeObject second) {
		super(first, second);
	}

	/**
	 * Initializes a <code>DuDeObjectPair</code> that contains no real data.
	 * This constructor can be used for referring to actual
	 * <code>DuDeObjectPairs</code>.
	 * 
	 * @param sourceId1
	 *            The source id of the first object.
	 * @param objectId1
	 *            The object id of the first object.
	 * @param sourceId2
	 *            The source id of the second object.
	 * @param objectId2
	 *            The object id of the second object.
	 */
	public DuDeObjectPair(String sourceId1, JsonArray objectId1, String sourceId2, JsonArray objectId2) {
		super(new DuDeObject(sourceId1, objectId1), new DuDeObject(sourceId2, objectId2));
	}

	/**
	 * 
	 * Initializes a <code>DuDeObjectPair</code> that contains no real data and
	 * where the object id is given as a single <code>String</code> value. This
	 * constructor can be used for referring to actual
	 * <code>DuDeObjectPairs</code>.
	 * 
	 * @param sourceId1
	 *            The source id of the first object.
	 * @param objectId1
	 *            The object id of the first object as a single
	 *            <code>String</code> value.
	 * @param sourceId2
	 *            The source id of the second object.
	 * @param objectId2
	 *            The object id of the second object as a single
	 *            <code>String</code> value.
	 */

	public DuDeObjectPair(String sourceId1, String objectId1, String sourceId2, String objectId2) {
		this(new DuDeObject(sourceId1, objectId1), new DuDeObject(sourceId2, objectId2));
	}

	/**
	 * Returns the data of the first {@link DuDeObject}.
	 * 
	 * @return A {@link JsonRecord} that stores all the data that describes the
	 *         real-world object which is represented by the first element.
	 */
	public JsonRecord getFirstElementObjectData() {
		return this.getFirstElement().getData();
	}

	/**
	 * Returns the data of the second {@link DuDeObject}.
	 * 
	 * @return A {@link JsonRecord} that stores all the data that describes the
	 *         real-world object which is represented by the second element.
	 */
	public JsonRecord getSecondElementObjectData() {
		return this.getSecondElement().getData();
	}

	/**
	 * Returns a <code>DuDeObjectPair</code> that refers to the current pair.
	 * 
	 * @return A reference to the current <code>DuDeObjectPair</code>.
	 */
	public DuDeObjectPair getReference() {
		DuDeObjectPair pair = new DuDeObjectPair(this.getFirstElement().getSourceId(), this.getFirstElement().getObjectId(), this.getSecondElement()
				.getSourceId(), this.getSecondElement().getObjectId());

		pair.copyPropertiesFrom(this);

		return pair;
	}

	@Override
	public String toString() {
		return "[" + this.getFirstElement().getObjectId() + "; " + this.getSecondElement().getObjectId() + "]";
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}

		if (obj == null) {
			return false;
		}

		if (this.getClass() != obj.getClass()) {
			return false;
		}

		DuDeObjectPair other = (DuDeObjectPair) obj;
		if (this.getFirstElement() == null) {
			if (other.getFirstElement() != null) {
				return false;
			}
		} else if (!this.getFirstElement().getObjectId().equals(other.getFirstElement().getObjectId())
				|| !this.getFirstElement().getSourceId().equals(other.getFirstElement().getSourceId())) {
			return false;
		}

		if (this.getSecondElement() == null) {
			if (other.getSecondElement() != null) {
				return false;
			}
		} else if (!this.getSecondElement().getObjectId().equals(other.getSecondElement().getObjectId())
				|| !this.getSecondElement().getSourceId().equals(other.getSecondElement().getSourceId())) {
			return false;
		}

		return true;
	}

	/**
	 * Checks whether the similarity is set.
	 * 
	 * @return <code>true</code>, if the similarity was set; otherwise
	 *         <code>false</code>.
	 */
	public boolean hasSimilarity() {
		final double similarity = this.getSimilarity();
		return similarity >= 0.0 && similarity <= 1.0;
	}

	/**
	 * Clears the similarity of this pair.
	 */
	public void clearSimilarity() {
		this.setSimilarity(DuDeObjectPair.NO_SIMILARITY_SET_VALUE);
	}

	/**
	 * Sets the similarity of this <code>DuDeObjectPair</code>. The passed value
	 * needs to be within the range [0;1]. Larger values will lead to a
	 * similarity of <code>1.0</code>. Smaller values will lead to a similarity
	 * of <code>0.0</code>.
	 * 
	 * @param val
	 *            The value which shall be set as a similarity.
	 */
	public void setSimilarity(double val) {
		if (val > 1.0) {
			this.setProperty(DuDeObjectPair.SIMILARITY_PROPERTY, 1.0);
		} else if (val < 0.0) {
			this.setProperty(DuDeObjectPair.SIMILARITY_PROPERTY, 0.0);
		} else {
			this.setProperty(DuDeObjectPair.SIMILARITY_PROPERTY, val);
		}
	}

	/**
	 * Returns the similarity of the <code>DuDeObjectPair</code> or
	 * {@link #NO_SIMILARITY_SET_VALUE}, if the similarity wasn't set.
	 * 
	 * @return The similarity of the pair or
	 *         <code>NO_SIMILARITY_SET_VALUE</code>, if it was not set.
	 */
	public double getSimilarity() {
		if (this.hasProperty(DuDeObjectPair.SIMILARITY_PROPERTY)) {
			return (Double) this.getProperty(DuDeObjectPair.SIMILARITY_PROPERTY);
		}

		return DuDeObjectPair.NO_SIMILARITY_SET_VALUE;
	}

	/**
	 * Checks whether a lineage is specified.
	 * 
	 * @return <code>true</code>, if the property is set and unequal to
	 *         {@link GeneratedBy#NotDefined}; otherwise <code>false</code>.
	 */
	public boolean hasLineage() {
		return this.getLineage() != GeneratedBy.NotDefined;
	}

	/**
	 * Clears the lineage property.
	 */
	public void clearLineage() {
		this.setLineage(GeneratedBy.NotDefined);
	}

	/**
	 * Sets the lineage property.
	 * 
	 * @param generatorType
	 *            The type of lineage that shall be set.
	 */
	public void setLineage(GeneratedBy generatorType) {
		if (generatorType != null) {
			this.setProperty(DuDeObjectPair.LINEAGE_PROPERTY, generatorType);
		} else {
			this.clearLineage();
		}
	}

	/**
	 * Returns the lineage value of the current pair.
	 * 
	 * @return The value of the lineage property.
	 */
	public GeneratedBy getLineage() {
		if (this.hasProperty(DuDeObjectPair.LINEAGE_PROPERTY)) {
			return (GeneratedBy) this.getProperty(DuDeObjectPair.LINEAGE_PROPERTY);
		}

		return GeneratedBy.NotDefined;
	}

	/**
	 * Checks whether the <code>is-duplicate</code> property is set.
	 * 
	 * @return <code>true</code>, if this property is set; otherwise
	 *         <code>false</code>.
	 */
	public boolean hasDuplicateInfo() {
		return this.getDuplicateInfo() != DuplicateType.NotDefined;
	}

	/**
	 * Clears the <code>is-duplicate</code> property.
	 */
	public void clearDuplicateInfo() {
		this.setDuplicateInfo(DuplicateType.NotDefined);
	}

	/**
	 * Sets the <code>is-duplicate</code> property. <code>null</code> unsets
	 * this property.
	 * 
	 * @param isDuplicate
	 *            The new value of the <code>is-duplicate</code> property.
	 */
	public void setDuplicateInfo(DuplicateType isDuplicate) {
		if (isDuplicate != null) {
			this.setProperty(DuDeObjectPair.DUPLICATE_PROPERTY, isDuplicate);
		} else {
			this.clearDuplicateInfo();
		}
	}

	/**
	 * Checks whether the current pair represents a duplicate.
	 * 
	 * @return The value of the <code>is-duplicate</code> property.
	 */
	public DuplicateType getDuplicateInfo() {
		if (this.hasProperty(DuDeObjectPair.DUPLICATE_PROPERTY)) {
			return (DuplicateType) this.getProperty(DuDeObjectPair.DUPLICATE_PROPERTY);
		}

		return DuplicateType.NotDefined;
	}

	/**
	 * Checks whether the current pair represents a duplicate.
	 * 
	 * @return <code>false</code>, if the pair does not represent a duplicate or
	 *         was not defined as a duplicate, yet; otherwise <code>false</code>
	 *         .
	 */
	public boolean isDuplicate() {
		return this.getDuplicateInfo() == DuplicateType.Duplicate;
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		if (this.getFirstElement() == null || this.getSecondElement() == null) {
			result = prime * result + ((this.getFirstElement() == null) ? 0 : this.getFirstElement().hashCode());
			result = prime * result + ((this.getSecondElement() == null) ? 0 : this.getSecondElement().hashCode());
		} else if (this.getFirstElement().compareTo(this.getSecondElement()) < 0) {
			result = prime * result + this.getFirstElement().hashCode();
			result = prime * result + this.getSecondElement().hashCode();
		} else {
			result = prime * result + this.getSecondElement().hashCode();
			result = prime * result + this.getFirstElement().hashCode();

		}

		return result;
	}

	@Override
	public void toJson(DuDeJsonGenerator jsonGenerator) throws JsonGenerationException, IOException {
		jsonGenerator.writeRecordStart();

		jsonGenerator.writeRecordFieldName(DuDeObjectPair.FIRST_ELEMENT_ATTRIBUTE_NAME);
		this.getFirstElement().toJson(jsonGenerator);

		jsonGenerator.writeRecordFieldName(DuDeObjectPair.SECOND_ELEMENT_ATTRIBUTE_NAME);
		this.getSecondElement().toJson(jsonGenerator);

		// check in lexicographical order!
		if (this.hasDuplicateInfo()) {
			jsonGenerator.writeRecordEntry(DuDeObjectPair.DUPLICATE_PROPERTY, new JsonString(this.getDuplicateInfo().name()));
		}

		if (this.hasLineage()) {
			jsonGenerator.writeRecordEntry(DuDeObjectPair.LINEAGE_PROPERTY, new JsonString(this.getLineage().name()));
		}

		if (this.hasSimilarity()) {
			jsonGenerator.writeRecordEntry(DuDeObjectPair.SIMILARITY_PROPERTY, new JsonNumber(this.getSimilarity()));
		}

		jsonGenerator.writeRecordEnd();
	}

	@Override
	public void fromJson(DuDeJsonParser<?> jsonParser) throws JsonParseException, IOException {
		jsonParser.skipToken(); // skip '{'

		if (!DuDeObjectPair.FIRST_ELEMENT_ATTRIBUTE_NAME.equals(jsonParser.nextFieldName())) {
			throw new JsonParseException("First element is missing.", null);
		}

		this.getFirstElement().fromJson(jsonParser);

		if (!DuDeObjectPair.SECOND_ELEMENT_ATTRIBUTE_NAME.equals(jsonParser.nextFieldName())) {
			throw new JsonParseException("Second element is missing.", null);
		}

		this.getSecondElement().fromJson(jsonParser);

		while (!jsonParser.endTokenReached()) {
			final String attrName = jsonParser.nextFieldName();
			if (DuDeObjectPair.DUPLICATE_PROPERTY.equals(attrName)) {
				this.setDuplicateInfo(DuplicateType.valueOf(jsonParser.nextJsonString().getStringValue()));
			} else if (DuDeObjectPair.LINEAGE_PROPERTY.equals(attrName)) {
				this.setLineage(GeneratedBy.valueOf(jsonParser.nextJsonString().getStringValue()));
			} else if (DuDeObjectPair.SIMILARITY_PROPERTY.equals(attrName)) {
				this.setSimilarity(jsonParser.nextJsonNumber().getValue().doubleValue());
			}
		}

		jsonParser.skipToken(); // skip '}'
	}
}
